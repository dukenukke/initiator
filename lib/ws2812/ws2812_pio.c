#include <stdio.h>
#include "pico/stdlib.h"
#include "hardware/pio.h"
#include "hardware/clocks.h"
#include "ws2812.pio.h" //generated by CMake
#include "ws2812_pio.h"

// PIO and state machine #
static PIO ws2812_pio = pio0;
static uint ws2812_sm  = 0;  // state machine №0 in PIO0
static uint ws2812_offset;   // offset program loaded

#define WS2812_FREQ  800000   // 800 kHz
#define WS2812_PIN   16       // GPIO WS2812 connected to

extern volatile bool interrupt_triggered;
extern volatile bool mus_active;
extern volatile bool rele_voltage_error;

/**
 * Initializes the WS2812 PIO (Programmable Input/Output) for controlling WS2812 LEDs.
 */

static inline void ws2812_program_init(float freq) {
    ws2812_offset = pio_add_program(ws2812_pio, &ws2812_program);
    pio_gpio_init(ws2812_pio, WS2812_PIN);
    pio_sm_set_consecutive_pindirs(ws2812_pio, ws2812_sm, WS2812_PIN, 1, true);

    pio_sm_config c = ws2812_program_get_default_config(ws2812_offset);
    sm_config_set_sideset_pins(&c, WS2812_PIN);
    sm_config_set_out_shift(&c, false, true, 24);
    sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_TX);

    int cycles_per_bit = ws2812_T1 + ws2812_T2 + ws2812_T3;
    float div = clock_get_hz(clk_sys) / ((float)WS2812_FREQ * cycles_per_bit);
    sm_config_set_clkdiv(&c, div);

    pio_sm_init(ws2812_pio, ws2812_sm, ws2812_offset, &c);
    pio_sm_set_enabled(ws2812_pio, ws2812_sm, true);
}


void ws2812_pio_init()
{
    // 1. Loads the WS2812 program into the PIO.
    ws2812_offset = pio_add_program(ws2812_pio, &ws2812_program);
    // 2. Initializes the GPIO16 pin as controlled by the PIO.
    pio_gpio_init(ws2812_pio, WS2812_PIN);
    // 3. Initializes the state machine with the configured settings.
    //    (pio_sm_set_pindirs_with_mask(...) or pio_sm_set_consecutive_pindirs(...))
    pio_sm_set_consecutive_pindirs(ws2812_pio, ws2812_sm, WS2812_PIN, 1, true);
    // 4. Configures the state machine with default settings, including:
    pio_sm_config c = ws2812_program_get_default_config(ws2812_offset);
    //  - Setting the sideset pin WS2812_PIN for output.
    sm_config_set_sideset_pins(&c, WS2812_PIN);
    //  - Configuring the output shifter to send 8 bits at a time.
    //    Since WS2812 requires 24 bits for 1 pixel, so, just send this byte 3 times 
    sm_config_set_out_shift(&c, false, true, 24);
    //  - Setting the clock divider for 800kHz and Fclk_pio ~125МГц
    //    set_clkdiv = (125000000 / 800000) = 156.25
    int cycles_per_bit = ws2812_T1 + ws2812_T2 + ws2812_T3;
    float div = (float)clock_get_hz(clk_sys) / ((float)WS2812_FREQ * cycles_per_bit);
    sm_config_set_clkdiv(&c, div);

    // 5. Enables the state machine to start operation.
    pio_sm_init(ws2812_pio, ws2812_sm, ws2812_offset, &c);
    pio_sm_set_enabled(ws2812_pio, ws2812_sm, true);
}

/**
 * Sends a single byte to the WS2812 PIO state machine.
 *
*/
static inline void ws2812_pio_send_byte(uint8_t b)
{
    // Write byte in TX FIFO (PIO divides it by bits by itself)
    pio_sm_put_blocking(ws2812_pio, ws2812_sm, (uint32_t)b);
}

// Send 1 pixel (GRB)
void ws2812_pio_send_pixel(uint8_t r, uint8_t g, uint8_t b)
{
    // Order: G, R, B (as WS2812 waiting for)
    //ws2812_pio_send_byte(g);
    //ws2812_pio_send_byte(r);
    //ws2812_pio_send_byte(b);
    uint32_t pixel = ( (g<<16) | (r<<8) | b ) << 8u;
    pio_sm_put_blocking(ws2812_pio, ws2812_sm, (uint32_t)pixel);
}

// Після відправлення всіх пікселів — пауза ~50+ мкс
// Для 1 пікселя це означає, що робимо "sleep_us(50)" чи трохи більше
void ws2812_pio_reset(void)
{
    // "Reset" WS2812: лінія LOW не менше ~50 мкс
    // PIO припиняє відправляти (оскільки FIFO порожній), 
    // тож на фізичному виводі буде 0. Просто почекаємо 80 мкс.
    sleep_us(80);
}
